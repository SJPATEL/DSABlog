<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="pythoncheatsheet.css">
    <link rel="stylesheet" href="prism.css">
    <script src="prism.js"></script>
    <title>Python Cheatsheets by Setu Patel</title>
</head>
<body>
     
    <nav class="nav">
        <img id="logo" src="logo.jpeg" alt="">
          Python program created by S.J.PATEL
    </nav>

    

    <div class="div">
        <ol>
            
            <li style="font-size: 1.2rem;">Write a program to insert, Traversing, Delete, Sorting a single Dimension Array. <pre class="language-c" style="font-size: 0.8rem;"><code >// Write a program to Insert, Traversing, Delete, Sorting, a single Diamesion array
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct opeArray{
    int total_size;
    int use_size;
    int *ptr;
};

// Crate Array 
void createArray(struct opeArray * ar, int array_size, int use_size){
    ar->total_size = array_size;
    ar->use_size = use_size;
    ar->ptr = (int *)malloc(array_size * sizeof(int));
}

// 1 Function of insert elemnt on array 
void insertElement(struct opeArray * ar){
    for(int i =0;  i< ar->use_size; i++){
        int n;
        printf("Insert element %d : ", i);
        scanf("%d",&n);
        (ar->ptr)[i] = n;
    }
}
// 2 Function of Delete elemnt on array 
void deleteElement(struct opeArray *ar, int pos){
    for(int i = pos; i < ar->use_size; i++){
        (ar->ptr)[i] = (ar->ptr)[i+1];
    }
    ar->use_size -= 1;
}
// 3 Function of Sort on array 
void sort(struct opeArray *ar){
    int key;
    int i,j;

    for(i = 0; i < ar->use_size; i++){
        key = (ar->ptr)[i];
        j = i-1;

        while(j >= 0 && key < (ar->ptr)[j]){
            (ar->ptr)[j+1] = (ar->ptr)[j];
            j--; 
        }
        (ar->ptr)[j+1] = key;
    }

}
// 4 Function of Traversing on array 
void traversArray(struct opeArray * ar){
    for(int i = 0; i < ar->use_size; i++){
        printf("%d ", (ar->ptr)[i]);
    }
    printf("\n");
}
int main(){
    
    struct opeArray numbers;
    int size;
    int ussize;
    int del;
    printf("Enter size of Array :");
    scanf("%d",&size);
    printf("Enter use size of Array :");
    scanf("%d",&ussize);

    createArray(&numbers,size,ussize);
    printf("Your Array has been successfully created \n");

    insertElement(&numbers);

    printf("Your element are : \n");
    traversArray(&numbers);

    
    printf("Enter delete element position of Array : \n");
    scanf("%d",&del);

    deleteElement(&numbers,del);
    printf("Your element has been successfully deleted \n");
    
    printf("After delete element  : \n");
    traversArray(&numbers);

    
    printf("After short array :");
    sort(&numbers);
    traversArray(&numbers);

    return 0;
}</code></pre></li>

            <li>Write a program to Marge two array lists.<pre class="language-c" style="font-size: 0.8rem;"><code>// Write a program to marge tow array lists
#include &lt;stdio.h&gt;

int main()
{
    int array1[5] = {1, 3, 5, 7, 9};
    int array2[5] = {2, 4, 6, 8, 0};

    // Get lenght of array 
    int ar1_length = sizeof(array1) / sizeof(array1[0]);
    int ar2_length = sizeof(array2) / sizeof(array2[0]);

    // Give new array 3 length 
    int array_size = ar1_length + ar2_length;
    int array3[array_size];

    // Insert array one element on array 3
    for(int i = 0; i < ar1_length; i++){
        array3[i]  = array1[i];
    }

    // Insert array two element on array 3
    int temp = ar1_length;
    for(int i = 0; i < ar2_length; i++){
        array3[temp]  = array1[i];
        temp++;
    }

    printf(" \n Array 1 element are: ");
    for(int i = 0; i < ar1_length; i++){
        printf("%d ", array1[i]);
    }
    printf(" \n Array 2 element are: ");
    for(int i = 0; i < ar2_length; i++){
        printf("%d ", array2[i]);
    }

    // Traverser array 3 
    printf(" \n After merge array \n");
    int array_lenght = sizeof(array3)/ sizeof(array3[0]);
    for(int i = 0; i < array_lenght; i++){
        printf("%d ", array3[i]);
    }
    printf("\n");

    return 0;
}
            </code></pre></li>

            <li>Write a program Insert, traversing, Delete, Sorting a 2-Dimension Array.<pre class="language-c" style="font-size: 0.8rem;"><code>
// Write a program Insert, Traversing, Delete, Sorting a 2-Dimension array 
#include &lt;stdio.h&gt;

#define ROWS 3
#define COLS 3

// Function to insert elements into the 2D array
void insertElement(int arr[ROWS][COLS], int row, int col, int value) {
    arr[row][col] = value;
}

// Function to traverse and print the elements of the 2D array
void traverseArray(int arr[ROWS][COLS]) {
    printf("Array Elements:\n");
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}

// Function to delete an element from the 2D array
void deleteElement(int arr[ROWS][COLS], int row, int col) {
    arr[row][col] = 0; // Assuming 0 represents deletion or empty element
}

// Function to sort the elements of the 2D array (using bubble sort)
void sortArray(int arr[ROWS][COLS]) {
    int temp;
    for (int i = 0; i < ROWS * COLS - 1; i++) {
        for (int j = 0; j < ROWS * COLS - i - 1; j++) {
            if (arr[j / COLS][j % COLS] > arr[(j + 1) / COLS][(j + 1) % COLS]) {
                temp = arr[j / COLS][j % COLS];
                arr[j / COLS][j % COLS] = arr[(j + 1) / COLS][(j + 1) % COLS];
                arr[(j + 1) / COLS][(j + 1) % COLS] = temp;
            }
        }
    }
}

int main() {
    int array[ROWS][COLS] = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};

    printf("Original Array:\n");
    traverseArray(array);

    // Insertion
    insertElement(array, 1, 1, 10);

    printf("\nArray after insertion:\n");
    traverseArray(array);

    // Deletion
    deleteElement(array, 1, 1);

    printf("\nArray after deletion:\n");
    traverseArray(array);

    // Sorting
    sortArray(array);

    printf("\nArray after sorting:\n");
    traverseArray(array);



    return 0;
}
                
            </code></pre></li>

            <li>Write a program for Addition, Subtraction, and Multiplication of matrices<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;

    #define ROWS 3
    #define COLS 3
    
    void printMatrixt(int matrix[ROWS][COLS])
    {
        // Printf after addtion of tow matrixt
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                printf("%d ", matrix[i][j]);
            }
            printf("\n");
        }
    }
    // 1 Matirx addition function
    int additionMatrix(int matrix1[ROWS][COLS], int matrix2[ROWS][COLS])
    {
        int addMatrix[ROWS][COLS];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                int add;
                add = matrix1[i][j] + matrix2[i][j];
                addMatrix[i][j] = add;
            }
            printf("\n");
        }
    
        printMatrixt(addMatrix);
    }
    
    // 2 Matirx subtriction function
    int subMatrix(int matrix1[ROWS][COLS], int matrix2[ROWS][COLS])
    {
        int subMatrix[ROWS][COLS];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                int add;
                add = matrix1[i][j] - matrix2[i][j];
                subMatrix[i][j] = add;
            }
            printf("\n");
        }
    
        printMatrixt(subMatrix);
    }
    
    // 3 Matirx multiplication function
    int mulMatrix(int matrix1[ROWS][COLS], int matrix2[ROWS][COLS])
    {
        int mulMatrix[ROWS][COLS];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                int add;
                add = matrix1[i][j] * matrix2[i][j];
                mulMatrix[i][j] = add;
            }
            printf("\n");
        }
    
        printMatrixt(mulMatrix);
    }
    
    int main()
    {
    
        int matrix1[ROWS][COLS] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        int matrix2[ROWS][COLS] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    
        printf("Matrix 1 element are:\n");
        printMatrixt(matrix1);
        printf("\nMatrix 2 element are:\n");
        printMatrixt(matrix2);
    
        printf("\nAfter Two matrix addition:\n");
        additionMatrix(matrix1, matrix2);
        
    
        printf("\nAfter Two matrix subtraction:\n");
        subMatrix(matrix1, matrix2);
        
    
        printf("\nAfter Two matrix multiplication:\n");
        mulMatrix(matrix1, matrix2);
        
    
        return 0;
    }
            </code></pre></li>

            <li>Implement Stack by using static & dynamic storage representation.
                (Push, pop, peep, display, isempty, isfull)<pre class="language-c" style="font-size: 0.8rem;"><code>
                    // Impliment Stack by using static & dynamic storage represtion

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct stack
{
    int size;
    int top;
    int *ptr;
};

int isFull(struct stack *s)
{
    if (s->top == s->size - 1)
    {
        return 1;
    }
    return 0;
}

int isEmpty(struct stack *s)
{
    if (s->top == -1)
    {
        return 1;
    }
    return 0;
}

void crateStack(struct stack *s, int size, int top)
{
    s->size = size;
    s->top = top;
    s->ptr = (int *)malloc((s->size) * sizeof(int));
}
void push(struct stack *s, int value)
{
    if (isFull(s))
    {
        printf("Stack is overflow");
    }
    else
    {
        s->top++;
        s->ptr[s->top] = value;
    }
}

int pop(struct stack *s)
{
    if (isEmpty(s))
    {
        printf("Stack is underflow");
    }
    else
    {
        int value = s->ptr[s->top];
        s->top--;
        return value;
    }
}

int peek(struct stack *s, int index)
{
    if ((s->top - index + 1) < 0)
    {
        return 0;
    }
    else
    {
        return s->ptr[s->top - index + 1];
    }
}

int main()
{
    struct stack *s;

    int sizeAray;
    int del;
    int top = -1;
    printf("Enter size of Stack :\n");
    scanf("%d", &sizeAray);

    crateStack(s,sizeAray, top);
    printf("\nStack has been successfully created  :\n");

    for (int i = 0; i < s->size; i++)
    {
        int n;
        printf("\nInsert element %d : \n", i);
        scanf("%d", &n);
        push(s, n);
    }

    printf("After insert Array  are: \n");
    for (int i = 1; i <= s->top + 1; i++)
    {
        printf("Element %d \n ", peek(s, i));
    }

  
    printf("\nEnter how many delete element: \n");
    scanf("%d", &del);
    for (int i = 0; i < del; i++)
    {
        printf("delete Element %d \n", pop(s));
    }

    printf("\nAfter delete element : \n");
    for (int i = 1; i <= s->top + 1; i++)
    {
        printf("Element %d \n ", peek(s, i));
    }

    return 0;
}
                </code></pre></li>
            <li> Write a program to print n Fibonacci series<pre class="language-c" style="font-size: 0.8rem;"><code>
                // Write a program to print fibosirise 

#include&lt;stdio.h&gt;

int fibosirise(int num){
    if(num == 0){
        return 0;
    }else if(num == 1){
        return 1;
    }else{
        return fibosirise(num - 2) + fibosirise(num - 1);
    }
}

int main(){
    int num;
    printf("Enter the numbner for get Fibonachisirise");
    scanf("%d",&num);

    for(int i = 0; i < num; i++){
        printf("%d \t",fibosirise(i));
    }
    return 0;
}
            </code></pre></li>
            <li>Write a program to find factorial of n number. <pre class="language-c" style="font-size: 0.8rem;"><code>
                // Write a program to print factorial 

#include&lt;stdio.h&gt;

int factorial(int num){
    if(num == 0){
        return 0;
    }else if(num == 1){
        return 1;
    }else{
        return num * factorial(num - 1);
    }
}

int main(){
    int num;
    printf("Enter the numbner for get Factorial");
    scanf("%d",&num);

    printf("%d \t",factorial(num));
    
    return 0;
}
            </code></pre></li>
            <li>Find X^N, i.e. power (x,n) <pre class="language-c" style="font-size: 0.8rem;"><code>
                // find a poer x^n 

#include&lt;stdio.h&gt;

int power(int num,int p){
    int power = 1;
    for(int i = 1; i <= p; i++){
        power = power * num;
    }
    return power;
}

int main(){
    int num,p;
    printf("Enter the numbner");
    scanf("%d",&num);
    printf("Enter the power for calculate given number");
    scanf("%d",&p);

    printf("%d \t",power(num,p));
    
    return 0;
}
            </code></pre></li>


            <li> Write a program for Single Queue operation (Insertion, Deletion).<pre class="language-c" style="font-size: 0.8rem;"><code>
                // Write a program for single Queue operation (Insert and Delete )
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct queue
{
    int f;
    int b;
    int size;
    int *ptr;
};
int isFull(struct queue *q)
{
    if (q->b == q->size - 1)
    {
        return 1;
    }
    return 0;
}
int isEmpty(struct queue *q)
{
    if (q->b == q->f)
    {
        return 1;
    }
    return 0;
}
void inqueue(struct queue *q, int value)
{
    if (isFull(q))
    {
        printf("Queue is overfolw");
    }
    else
    {
        q->b++;
        q->ptr[q->b] = value;
    }
}

int dequeue(struct queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is underflow");
    }
    else
    {
        int value = q->ptr[q->f];
        q->f++;
        return value;
    }
}


int main()
{
    struct queue *q;
    q->size = 10;
    q->f = -1;
    q->b = -1;
    q->ptr = (int *)malloc((q->size) * sizeof(int));
            
    printf("Insert element \n");
    inqueue(q, 10);
    inqueue(q, 30);
    inqueue(q, 20);
    
    printf("Delete element \n");

    dequeue(q);

    for (int i = 0; i <= q->b - 1; i++)
    {
        printf("Element %d : %d \n", i + 1, q->ptr[i]);
    }

    return 0;
}
            </code></pre></li>
            <li>Write a program for Circular Queue operations (Insertion, Deletion)<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct circulerQueue
{
    int size;
    int f;
    int r;
    int *arr;
};

int isFull(struct circulerQueue *q)
{
    if ((q->r + 1) % q->size == q->f)
    {
        return 1;
    }
    return 0;
}
int isEmpty(struct circulerQueue *q)
{
    if (q->r == q->f)
    {
        return 1;
    }
    return 0;
}
void enqueue(struct circulerQueue *q, int value)
{
    if (isFull(q))
    {
        printf("Queue is overflow");
    }
    else
    {
        q->r = (q->r + 1) % q->size;
        q->arr[q->r] = value;
        printf("Enqueue Element : %d \n", value);
    }
}
int dequeue(struct circulerQueue *q)
{
    int a = -1;
    if (isEmpty(q))
    {
        return 0;
    }
    else
    {
        q->f = (q->f + 1) % q->size;
        ;
        a = q->arr[q->f];
    }
    return a;
}
int main()
{
    struct circulerQueue q;
    q.size = 4;
    q.f = q.r = 0;
    q.arr = (int *)malloc(q.size * sizeof(int));
    int del;

    printf("Insert Element successfully \n");
    enqueue(&q, 20);
    enqueue(&q, 30);
    enqueue(&q, 40);

    printf("\nAfter insert element \n");
    for (int i = q.f + 1; i <= q.r; i++)
    {
        printf("Element %d : %d \n", i, q.arr[i]);
    }

    printf("\n Enter number of delete element\n");
    scanf("%d", &del);

    for (int i = 0; i < del; i++)
    {
        printf("Dequeue element : %d \n", dequeue(&q));
    }

    if (isEmpty(&q))
    {
        printf("Queue is empty \n");
    }
    if (isFull(&q))
    {
        printf("Queue is underFlow \n");
    }

    printf("After delete element \n");
    for (int i = q.f; i < q.r; i++)
    {
        printf("Element %d : %d \n", i, q.arr[i]);
    }

    return 0;
}
            </code></pre></li>
          
            
            <li>Write a menu driven program that implements singly linked list for the above operations. <pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Define the structure of a node
struct Node {
    int data;
    struct Node* next;
};

// Function to display the linked list
void display(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to insert a node at the beginning of the linked list
struct Node* insert(struct Node* head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = head;
    return newNode;
}

// Function to delete a node with given key from the linked list
struct Node* deleteNode(struct Node* head, int key) {
    struct Node *temp = head, *prev = NULL;
    if (temp != NULL && temp->data == key) {
        head = temp->next;
        free(temp);
        return head;
    }
    while (temp != NULL && temp->data != key) {
        prev = temp;
        temp = temp->next;
    }
    if (temp == NULL) return head;
    prev->next = temp->next;
    free(temp);
    return head;
}

// Function to search for a given key in the linked list
int search(struct Node* head, int key) {
    struct Node* current = head;
    while (current != NULL) {
        if (current->data == key) {
            return 1; // Key found
        }
        current = current->next;
    }
    return 0; // Key not found
}

int main() {
    struct Node* head = NULL; 
    int size;
    int se;
    int del;
    // Inserting some elements
    printf("Enter the size of link link list:\n");
    scanf("%d",&size);

    for (int i = 0; i < size; i++)
    {
        int n;
        printf("Insert element %d : \n", i);
        scanf("%d", &n);
        head = insert(head, n);
    }
    

    printf("\n Linked list elements: ");
    display(head);

    printf("Enter search element on link link list:\n");
    scanf("%d",&se);

    int searchKey = se;
    if (search(head, searchKey))
        printf("%d found in the list.\n", searchKey);
    else
        printf("%d not found in the list.\n", searchKey);


    printf("Enter delete element on link link list:\n");
    scanf("%d",&del);

    int deleteKey = del;
    head = deleteNode(head, deleteKey);

    printf("Linked list after deleting %d: ", deleteKey);

    printf("\n After delete element :\n");
    display(head);

    return 0;
}
                    
            </code></pre></li>
            <li>Write a menu driven program that implements doubly linked list for above operations.
                <pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Structure for a doubly linked list node
struct Node
{
    int data;
    struct Node *prev;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int data)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    if (newNode == NULL)
    {
        printf("Memory allocation failed!\n");
        exit(1);
    }
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the beginning of the list
void insertAtBeginning(struct Node **headRef, int data)
{
    struct Node *newNode = createNode(data);
    if (*headRef == NULL)
    {
        *headRef = newNode;
    }
    else
    {
        newNode->next = *headRef;
        (*headRef)->prev = newNode;
        *headRef = newNode;
    }
}

// Function to display the doubly linked list
void display(struct Node *head)
{
    printf("Doubly linked list: ");
    while (head != NULL)
    {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

// Function to search for a node with given data
struct Node *search(struct Node *head, int data)
{
    while (head != NULL)
    {
        if (head->data == data)
        {
            return head;
        }
        head = head->next;
    }
    return NULL;
}

// Function to delete a node with given data
void deleteNode(struct Node **headRef, int data)
{
    struct Node *nodeToDelete = search(*headRef, data);
    if (nodeToDelete == NULL)
    {
        printf("Node with data %d not found.\n", data);
        return;
    }
    if (nodeToDelete->prev != NULL)
    {
        nodeToDelete->prev->next = nodeToDelete->next;
    }
    else
    {
        *headRef = nodeToDelete->next;
    }
    if (nodeToDelete->next != NULL)
    {
        nodeToDelete->next->prev = nodeToDelete->prev;
    }
    free(nodeToDelete);
    printf("Node with data %d deleted successfully.\n", data);
}

int main()
{
    struct Node *head = NULL;
    int size;
    int se;
    int del;
    // Inserting some elements
    printf("Enter the size of link link list:\n");
    scanf("%d", &size);

    for (int i = 0; i < size; i++)
    {
        int n;
        printf("Insert element %d : \n", i);
        scanf("%d", &n);
        insertAtBeginning(&head, n);
    }

    printf("\n Linked list elements: ");
    // Display the list
    display(head);

    printf("Enter search element on link link list:\n");
    scanf("%d", &se);
    // Search for a node
    int searchData = se;
    struct Node *searchResult = search(head, searchData);
    if (searchResult != NULL)
    {
        printf("Node with data %d found.\n", searchData);
    }
    else
    {
        printf("Node with data %d not found.\n", searchData);
    }

    printf("Enter delete element on link link list:\n");
    scanf("%d", &del);

    // Delete a node
    int deleteData = del;
    deleteNode(&head, deleteData);
    printf("\n After delete element :\n");
    display(head);

    return 0;
}
                        
                </code></pre></li>
            <li>Write a menu driven program that implements circular linked list for the above operation<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Structure for a node
struct Node
{
    int data;
    struct Node *next;
};

// Function to display the circular linked list
void display(struct Node *head)
{
    struct Node *temp = head;

    if (head == NULL)
    {
        printf("List is empty\n");
        return;
    }

    do
    {
        printf("%d ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("\n");
}

// Function to insert a node at the beginning of the circular linked list
struct Node *insert(struct Node *head, int value)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;

    if (head == NULL)
    {
        newNode->next = newNode; // For the first node
    }
    else
    {
        newNode->next = head->next;
        head->next = newNode;
    }
    return newNode;
}

// Function to delete a node from the circular linked list
struct Node *deleteNode(struct Node *head, int key)
{
    if (head == NULL)
    {
        printf("List is empty\n");
        return NULL;
    }

    struct Node *temp = head;
    struct Node *prev = NULL;

    // Find the node to be deleted
    while (temp->data != key)
    {
        if (temp->next == head)
        {
            printf("Element not found in the list\n");
            return head;
        }
        prev = temp;
        temp = temp->next;
    }

    // If the node to be deleted is the only node in the list
    if (temp->next == head)
    {
        free(temp);
        return NULL;
    }

    // If the node to be deleted is the first node
    if (temp == head)
    {
        prev = head;
        while (prev->next != head)
            prev = prev->next;
        head = temp->next;
        prev->next = head;
        free(temp);
    }
    else
    {
        prev->next = temp->next;
        free(temp);
    }

    return head;
}

// Function to search for a node in the circular linked list
void search(struct Node *head, int key)
{
    if (head == NULL)
    {
        printf("List is empty\n");
        return;
    }

    struct Node *temp = head;
    int found = 0;
    int position = 1;

    do
    {
        if (temp->data == key)
        {
            printf("%d found at position %d\n", key, position);
            found = 1;
            break;
        }
        temp = temp->next;
        position++;
    } while (temp != head);

    if (!found)
        printf("%d not found in the list\n", key);
}

int main()
{
    struct Node *head = NULL;

    int size;
    int se;
    int del;
    // Inserting some elements
    printf("Enter the size of link link list:\n");
    scanf("%d", &size);

    for (int i = 0; i < size; i++)
    {
        int n;
        printf("Insert element %d : \n", i);
        scanf("%d", &n);
        head = insert(head, n);
    }

    printf("Circular Linked List: ");
    display(head);

    printf("Enter delete element on link link list:\n");
    scanf("%d", &del);
    // Deleting a node
    head = deleteNode(head, del);

    printf("After deleting element: ");
    display(head);

    // Searching for a node
    printf("Enter search element on link link list:\n");
    scanf("%d", &se);
    search(head, se);

    return 0;
}
                    
            </code></pre></li>

            <li>Write a program to create a graph in an adjacency list structure. (Node directory structure) traverse
             It in DFS.<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;


int visited[7] = {0, 0, 0, 0, 0, 0, 0};
int a[7][7] = {
    {0, 1, 1, 1, 0, 0, 0},
    {1, 0, 1, 0, 0, 0, 0},
    {1, 1, 0, 1, 1, 0, 0},
    {1, 0, 1, 0, 1, 0, 0},
    {0, 0, 1, 1, 0, 1, 1},
    {0, 0, 0, 0, 1, 0, 0},
    {0, 0, 0, 0, 1, 0, 0}};

void DFS(int i)
{
    printf("%d", i);
    visited[i] = 1;
    for (int j = 0; j < 7; j++)
    {
        if (a[i][j] == 1 && visited[j] == 0)
        {
            DFS(j);
        }
    }
}

int main()
{

    //  Depth for search code
    DFS(4);

    return 0;
}
             </code></pre></li>
            <li> Write a program to create a graph in an adjacency list structure. (Node directory structure) traverse
                it In BFS<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct queue
{
    int size;
    int f;
    int r;
    int *arr;
};

int isFull(struct queue *q)
{
    if (q->r == q->size - 1)
    {
        return 1;
    }
    return 0;
}
int isEmpty(struct queue *q)
{
    if (q->r == q->f)
    {
        return 1;
    }
    return 0;
}

void enqueue(struct queue *q, int value)
{
    if (isFull(q))
    {
        printf("Queue is overflow");
    }
    else
    {
        q->r++;
        q->arr[q->r] = value;
    }
}
int dequeue(struct queue *q)
{
    int a = -1;
    if (isEmpty(q))
    {
        return 0;
    }
    else
    {
        q->f++;
        a = q->arr[q->f];
    }
    return a;
}
void enqueAtFirst(struct queue *q, int value)
{
    if (q->f == -1)
    {
        printf("Not insert Alemnt at the first becouse not it not empty");
    }
    else
    {
        q->arr[q->f] = value;
        q->f--;
    }
}
int dequeAtLast(struct queue *q)
{
    int a = 0;
    if (q->r == -1)
    {
        // printf("Not delete any element becouse queue is empty");
        return a;
    }
    else
    {
        a = q->arr[q->r];
        q->r--;
        return a;
    }
}
int main()
{
    struct queue q;
    q.size = 7;
    q.f = q.r = -1;
    q.arr = (int *)malloc(q.size * sizeof(int));

    //  Breth for search code 
    int node;
    int i = 3;
    int visited[7] ={0,0,0,0,0,0,0};
    int a[7][7] = {
        {0,1,1,1,0,0,0},
        {1,0,1,0,0,0,0},
        {1,1,0,1,1,0,0},
        {1,0,1,0,1,0,0},
        {0,0,1,1,0,1,1},
        {0,0,0,0,1,0,0},
        {0,0,0,0,1,0,0}
    };
    printf("%d",i);
    visited[i] = 1;
    enqueue(&q,i); // enqueue i for exploration
    while (!isEmpty(&q))
    {
        int node= dequeue(&q);
        for (int j = 0; j < 7; j++)
        {
            if(a[node][j] == 1 && visited[j] == 0){
                printf("%d", j);
                visited[j] = 1;
                enqueue(&q,j);
            }
        }
        
    }
    
    return 0;
}
                </code></pre></li>


            <li>Write a program for linear Search. <pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;

// it is linerSeraching
int linearSearch(int arr[], int size, int element)
{
    for (int i = 0; i < size; i++)
    {
        if (arr[i] == element)
        {
            return i;
        }
    }
    return -1;
}


int main()
{

    int elm;
    int arraySize;
    printf("\nEntr array size for create array : \n");
    scanf("%d", &arraySize);

    int arr[arraySize];
    for (int i = 0; i < arraySize; i++)
    {
        int n;
        printf("Insert element %d :", i + 1);
        scanf("%d", &n);
        arr[i] = n;
        printf("\n");
    }



    printf("Enter element for linear search :\n");
    scanf("%d", &elm);
    int element = elm;

    int Search = linearSearch(arr, arraySize, element);

    printf("The Linear search  element  index is %d and value is %d", Search, element);


    return 0;
}
            </code></pre></li>
            <li>Write a program for binary Search<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;



int binarySearch(int arr[], int size, int element)
{
    int low, high, mid;
    low = 0;
    high = size - 1;
    while (low <= high)
    {
        mid = (low + high) / 2;
        // if(arr[low] == element){
        //     return  low;
        // }
        // if(arr[high] == element){
        //     return high;
        // }
        if (arr[mid] == element)
        {
            return mid;
        }
        else
        {
            if (arr[mid] > element)
            {
                high = mid - 1;
            }
            else
            {
                low = mid + 1;
            }
        }
    }
}
int main()
{

    int elm;
    int arraySize;
    printf("\nEntr array size for create array : \n");
    scanf("%d", &arraySize);

    int arr[arraySize];
    for (int i = 0; i < arraySize; i++)
    {
        int n;
        printf("Insert element %d :", i + 1);
        scanf("%d", &n);
        arr[i] = n;
        printf("\n");
    }

    

    printf("Enter element for Binary search :\n");
    scanf("%d", &elm);
    int element = elm;

    int Search = binarySearch(arr , arraySize , element);

    printf("The Binary search  element  index is %d and value is %d", Search, element);

    
    return 0;
}
            </code></pre></li>
            <li>Write a program for implementation of Bubble Sort<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;

void printArray(int *A, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", A[i]);
    }
    printf("\n");
}

// ==> Make Adptive bubbleShort
void BubbleShort(int *A, int n)
{
    int isShorted = 0;
    int temp;
    for (int i = 0; i < n - 1; i++)
    {
        isShorted = 1;
        printf("Working of pass number %d\n",i+1);
        for (int j = 0; j < n - 1 - i; j++)
        {
            if (A[j] > A[j + 1])
            {
                temp = A[j];
                A[j] = A[j + 1];
                A[j + 1] = temp;
                isShorted = 0;
            }
        }
        if (isShorted)
        {
            return;
        }
    }
}
int main()
{

    int A[] = {7, 10, 12, 14, 20};
    int n = 5;
    printArray(A, n);
    BubbleShort(A, n);
    printArray(A, n);

    return 0;
}
            </code></pre></li>
            <li>Write a program for implementation of Insertion Sort<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;

void printArray(int *A, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", A[i]);
    }
    printf("\n");
}

void insertionShort(int *A ,int n){
    int key,j;
    // 1] cheac how many muber of shop 
    for (int i = 1; i <= n-1; i++)
    {
        // 2] key = curent vlaue 
        key = A[i];
        // 3] j = current value  -1 
        j = i-1;
    
        while (j >= 0 && key < A[j])
        {
            A[j+1] = A[j];
            j--;
        }
        A[j+1] = key;
        
        
    }
    
}
int main()
{
    int A[] = {7,12,3,4,1};
    int n = 5;
    printArray(A,n);
    insertionShort(A,n);
    printArray(A,n);

    return 0;
}
            </code></pre></li>
            <li>Write a program for implementation of Quick Sort<pre class="language-c" style="font-size: 0.8rem;"><code>
#include &lt;stdio.h&gt;

void printArray(int A[], int lenght)
{
    for (int i = 0; i < lenght; i++)
    {
        printf("%d ", A[i]);
    }
}
int indexQuickShort(int A[], int low, int high)
{
    int pivwots = A[low];
    int i = low+1;
    int j = high;
    int temp;
    do
    {
        while (A[i] <= pivwots)
        {
            i++;
        }

        while (pivwots < A[j])
        {
            j--;
        }

        if (i < j)
        {
            temp = A[i];
            A[i] = A[j];
            A[j] = temp;
        }
    }while(i < j);
    temp = A[low];
    A[low] = A[j];
    A[j] = temp;

    return j;
}
void quickShort(int A[], int low, int high)
{

    int partitionIndex;

    if (low < high)
    {
        partitionIndex = indexQuickShort(A, low, high);
        quickShort(A, low, partitionIndex - 1);
        quickShort(A, partitionIndex + 1, high);
    }
}
int main()
{
    int A[] = {2, 4, 3, 9, 1, 4, 8, 7, 5, 6};
    int n = 10;
    printArray(A, n);
    // 0 == low and n-1 == high
    quickShort(A, 0, n - 1);
    printf("\n");
    printArray(A, n);
    return 0;
}
            </code></pre></li>


        </ol>
    </div>

</body>
</html>